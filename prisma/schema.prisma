generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * ---------------------- Enums ----------------------
 */

enum Role {
  ADMINISTRATEUR
  NOTAIRE
  OPERATEUR
  REVIEWER
  UTILISATEUR
}

enum ClientType {
  PERSONNE_PHYSIQUE
  PERSONNE_MORALE
}

enum ProfilType {
  PROPRIETAIRE
  LOCATAIRE
  LEAD
}

enum FamilyStatus {
  CELIBATAIRE
  MARIE
  DIVORCE
  VEUF
  PACS
}

enum MatrimonialRegime {
  COMMUNAUTE_REDUITE
  SEPARATION_DE_BIENS
  PARTICIPATION_AUX_AQUETS
  COMMUNAUTE_UNIVERSELLE
}

enum CompletionStatus {
  NOT_STARTED // aucune donnée encore envoyée
  PARTIAL // certaines données envoyées par le formulaire
  PENDING_CHECK // données envoyées par le client, en attente de vérification par nous 
  COMPLETED // toutes les données requises sont conformes et verifier par nous 
}

enum PropertyStatus {
  LOUER
  NON_LOUER
}

enum BienType {
  APPARTEMENT
  MAISON
}

enum BienLegalStatus {
  PLEIN_PROPRIETE
  CO_PROPRIETE
  LOTISSEMENT
}

enum BailType {
  BAIL_NU_3_ANS
  BAIL_NU_6_ANS
  BAIL_MEUBLE_1_ANS
  BAIL_MEUBLE_9_MOIS
}

enum BailFamille {
  HABITATION
  COMMERCIAL
}

enum BailStatus {
  DRAFT // brouillon, pas toute les données sont remplies
  PENDING_VALIDATION // en attente de validation par bailnotarie si toute les donne sont remplies
  READY_FOR_NOTARY // prêt pour notaire
  CLIENT_CONTACTED // client contacté
  SIGNED // signé
  TERMINATED // terminé
}

enum IntakeTarget {
  OWNER
  TENANT
  LEAD
  PROPERTY
  BAIL
}

enum IntakeStatus {
  PENDING
  SUBMITTED
  EXPIRED
  REVOKED
}

enum CommentTarget {
  CLIENT
  PROPERTY
  BAIL
  DOCUMENT
  INTAKE
  LEAD
}

enum NotificationType {
  COMMENT_CREATED
  CLIENT_CREATED
  CLIENT_CREATED_FROM_LANDING_PAGE
  CLIENT_UPDATED
  CLIENT_DELETED
  PROPERTY_CREATED
  PROPERTY_UPDATED
  PROPERTY_DELETED
  BAIL_CREATED
  BAIL_UPDATED
  BAIL_DELETED
  BAIL_STATUS_CHANGED
  INTAKE_SUBMITTED
  INTAKE_REVOKED
  COMPLETION_STATUS_CHANGED
  LEAD_CREATED
  LEAD_CONVERTED
}

enum DocumentKind {
  // morale
  KBIS
  STATUTES

  INSURANCE
  TITLE_DEED

  ID_IDENTITY
  LIVRET_DE_FAMILLE
  CONTRAT_DE_PACS

  //biens
  DIAGNOSTICS
  REGLEMENT_COPROPRIETE
  CAHIER_DE_CHARGE_LOTISSEMENT
  STATUT_DE_LASSOCIATION_SYNDICALE

  RIB

  OTHER
}

model Comment {
  id         String   @id @default(cuid())
  name       String
  email      String
  content    String
  isApproved Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  articleId  String

  @@index([articleId])
  @@map("comments")
}

/**
 * ---------------------- Users/Auth -----------------
 */

model User {
  id            String   @id @default(cuid())
  email         String   @unique
  emailVerified Boolean
  name          String?
  image         String?
  role          Role     @default(ADMINISTRATEUR)
  clientId      String? // Lien optionnel vers un Client
  client        Client?  @relation("UserClient", fields: [clientId], references: [id])
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Better Auth relations
  sessions Session[]
  accounts Account[]

  // Back-relations nommées
  comments              CommentInterface[] @relation("CommentCreatedBy")
  commentsRead          CommentRead[]      @relation("CommentReadByUser")
  uploadedDocuments     Document[]         @relation("DocumentUploadedBy")
  clientsCreated        Client[]           @relation("ClientCreatedBy")
  clientsUpdated        Client[]           @relation("ClientUpdatedBy")
  personsCreated        Person[]           @relation("PersonCreatedBy")
  personsUpdated        Person[]           @relation("PersonUpdatedBy")
  entreprisesCreated    Entreprise[]       @relation("EntrepriseCreatedBy")
  entreprisesUpdated    Entreprise[]       @relation("EntrepriseUpdatedBy")
  propertiesCreated     Property[]         @relation("PropertyCreatedBy")
  propertiesUpdated     Property[]         @relation("PropertyUpdatedBy")
  bailsCreated          Bail[]             @relation("BailCreatedBy")
  bailsUpdated          Bail[]             @relation("BailUpdatedBy")
  intakeLinksCreated    IntakeLink[]       @relation("IntakeLinkCreatedBy")
  notificationsCreated  Notification[]     @relation("NotificationCreatedBy")
  notificationsReceived Notification[]     @relation("NotificationReceivedBy")

  // Relations pour les assignations de dossiers
  notaireAssignments        DossierNotaireAssignment[] @relation("NotaireAssignments")
  dossierAssignmentsCreated DossierNotaireAssignment[] @relation("DossierAssignmentsCreated")

  // Relations pour les demandes du notaire
  notaireRequestsCreated NotaireRequest[] @relation("NotaireRequestCreatedBy")

  // Messages de chat sur les baux
  bailMessagesSent BailMessage[] @relation("BailMessageSender")
}

/**
 * ---------------------- Parties --------------------
 */

model Client {
  id         String     @id @default(cuid())
  type       ClientType
  // Sous-profils (1-1)
  profilType ProfilType

  completionStatus CompletionStatus @default(NOT_STARTED)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String?
  updatedById String?
  createdBy   User?    @relation("ClientCreatedBy", fields: [createdById], references: [id])
  updatedBy   User?    @relation("ClientUpdatedBy", fields: [updatedById], references: [id])

  persons    Person[]
  entreprise Entreprise?

  ownedProperties Property[] @relation("OwnerProperties")

  documents Document[]

  bails Bail[] @relation("BailClients")

  intakeLinks IntakeLink[]

  dossierAssignments DossierNotaireAssignment[] @relation("DossierNotaireAssignments")

  // Relation vers User (pour les utilisateurs clients)
  users User[] @relation("UserClient")

  // Messages reçus (pour les messages privés du notaire)
  receivedMessages BailMessage[] @relation("BailMessageRecipient")

  @@index([type])
}

model Person {
  id       String @id @default(cuid())
  clientId String
  client   Client @relation(fields: [clientId], references: [id], onDelete: Cascade)

  firstName  String?
  lastName   String?
  profession String?

  phone       String?
  email       String? @unique
  fullAddress String?
  nationality String?

  familyStatus      FamilyStatus?
  matrimonialRegime MatrimonialRegime?
  birthPlace        String?
  birthDate         DateTime?

  isPrimary Boolean @default(false)

  documents Document[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  createdById String?
  updatedById String?
  createdBy   User?   @relation("PersonCreatedBy", fields: [createdById], references: [id])
  updatedBy   User?   @relation("PersonUpdatedBy", fields: [updatedById], references: [id])

  @@index([clientId])
  @@index([email])
}

model Entreprise {
  id String @id @default(cuid())

  clientId String @unique
  client   Client @relation(fields: [clientId], references: [id], onDelete: Cascade)

  registration String
  legalName    String

  name        String
  email       String  @unique
  phone       String?
  fullAddress String?

  documents Document[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String?
  updatedById String?
  createdBy   User?    @relation("EntrepriseCreatedBy", fields: [createdById], references: [id])
  updatedBy   User?    @relation("EntrepriseUpdatedBy", fields: [updatedById], references: [id])

  @@index([clientId])
  @@index([email])
}

/**
 * ---------------------- Properties -----------------
 */

model Property {
  id          String           @id @default(cuid())
  label       String?
  fullAddress String
  surfaceM2   Decimal?         @db.Decimal(12, 2)
  type        BienType?
  legalStatus BienLegalStatus?
  status      PropertyStatus   @default(NON_LOUER)

  // Données géographiques enrichies (via API BAN)
  housenumber String?
  street      String?
  city        String?
  postalCode  String?
  district    String? // Arrondissement pour Paris/Lyon/Marseille
  inseeCode   String?
  department  String?
  region      String?
  latitude    Decimal?         @db.Decimal(10, 8)
  longitude   Decimal?         @db.Decimal(11, 8)
  isTightZone Boolean          @default(false)
  hasRentControl Boolean       @default(false)

  // Mobilier obligatoire pour location meublée
  hasLiterie           Boolean @default(false) // Literie avec couette ou couverture
  hasRideaux           Boolean @default(false) // Volets ou rideaux dans les chambres
  hasPlaquesCuisson    Boolean @default(false) // Plaques de cuisson
  hasFour              Boolean @default(false) // Four ou four à micro-onde
  hasRefrigerateur     Boolean @default(false) // Réfrigérateur
  hasCongelateur       Boolean @default(false) // Congélateur ou compartiment à congélation (-6°)
  hasVaisselle         Boolean @default(false) // Vaisselle en nombre suffisant
  hasUstensilesCuisine Boolean @default(false) // Ustensiles de cuisine
  hasTable             Boolean @default(false) // Table
  hasSieges            Boolean @default(false) // Sièges
  hasEtageresRangement Boolean @default(false) // Étagères de rangement
  hasLuminaires        Boolean @default(false) // Luminaires
  hasMaterielEntretien Boolean @default(false) // Matériel d'entretien ménager

  ownerId String
  owner   Client @relation("OwnerProperties", fields: [ownerId], references: [id])

  completionStatus CompletionStatus @default(NOT_STARTED)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  createdById      String?
  updatedById      String?
  createdBy        User?            @relation("PropertyCreatedBy", fields: [createdById], references: [id])
  updatedBy        User?            @relation("PropertyUpdatedBy", fields: [updatedById], references: [id])

  documents Document[]
  intakes   IntakeLink[] @relation("PropertyIntakes")
  bails     Bail[]       @relation("PropertyBails")

  dossierAssignments DossierNotaireAssignment[] @relation("DossierNotaireAssignments")

  @@index([status])
  @@index([ownerId])
  @@index([inseeCode])
  @@index([isTightZone])
}

/**
 * ---------------------- Zones Tendues ---------------------
 */

model ZoneTendue {
  id               String   @id @default(cuid())
  inseeCode        String  @unique
  city             String
  postalCode       String
  department       String
  region           String
  isActive         Boolean  @default(true)
  rentControlEnabled Boolean @default(false)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  rentControls RentControl[]

  @@index([inseeCode])
  @@index([isActive])
  @@index([rentControlEnabled])
}

model RentControl {
  id           String   @id @default(cuid())
  zoneTendueId String
  zoneTendue   ZoneTendue @relation(fields: [zoneTendueId], references: [id], onDelete: Cascade)
  propertyType BienType
  maxRentPerM2 Decimal  @db.Decimal(10, 2)
  effectiveDate DateTime
  endDate      DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([zoneTendueId])
  @@index([propertyType])
  @@index([effectiveDate])
}

/**
 * ---------------------- Bails ---------------------
 */

model Bail {
  id         String      @id @default(cuid())
  bailType   BailType    @default(BAIL_NU_3_ANS)
  bailFamily BailFamille @default(HABITATION)
  status     BailStatus  @default(DRAFT)

  // Montants « figés »
  rentAmount      Int
  monthlyCharges  Int @default(0)
  securityDeposit Int @default(0)

  effectiveDate DateTime
  endDate       DateTime?
  paymentDay    Int?

  propertyId String
  property   Property @relation("PropertyBails", fields: [propertyId], references: [id])

  parties Client[] @relation("BailClients")

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String?
  updatedById String?
  createdBy   User?    @relation("BailCreatedBy", fields: [createdById], references: [id])
  updatedBy   User?    @relation("BailUpdatedBy", fields: [updatedById], references: [id])

  documents Document[]
  intakes   IntakeLink[] @relation("BailIntakes")

  dossierAssignments DossierNotaireAssignment[] @relation("DossierNotaireAssignments")

  // Messages de chat
  messages BailMessage[]

  @@index([status])
  @@index([propertyId])
  @@index([effectiveDate])
}

/**
 * ---------------------- Bail Messages (Chat) ---------------
 */

enum BailMessageType {
  MESSAGE // Message texte normal
  REQUEST // Message lié à une demande NotaireRequest
}

model BailMessage {
  id               String          @id @default(cuid())
  bailId           String
  bail             Bail            @relation(fields: [bailId], references: [id], onDelete: Cascade)
  senderId         String
  sender           User            @relation("BailMessageSender", fields: [senderId], references: [id])
  messageType      BailMessageType @default(MESSAGE)
  content          String
  documentId       String?
  document         Document?       @relation("BailMessageDocument", fields: [documentId], references: [id], onDelete: SetNull)
  notaireRequestId String?
  notaireRequest   NotaireRequest? @relation("BailMessageRequest", fields: [notaireRequestId], references: [id], onDelete: SetNull)
  recipientPartyId String? // ID de la partie destinataire (pour messages privés du notaire à une partie spécifique)
  recipientParty   Client?         @relation("BailMessageRecipient", fields: [recipientPartyId], references: [id], onDelete: SetNull)
  createdAt        DateTime        @default(now())

  @@index([bailId])
  @@index([senderId])
  @@index([createdAt])
  @@index([notaireRequestId])
  @@index([documentId])
  @@index([recipientPartyId])
}

/**
 * ---------------------- Intake Links ---------------
 */

model IntakeLink {
  id     String       @id @default(cuid())
  token  String       @unique @default(uuid())
  target IntakeTarget

  propertyId String?
  property   Property? @relation("PropertyIntakes", fields: [propertyId], references: [id])

  bailId String?
  bail   Bail?   @relation("BailIntakes", fields: [bailId], references: [id])

  clientId String?
  client   Client? @relation(fields: [clientId], references: [id])

  status      IntakeStatus @default(PENDING) // PENDING | SUBMITTED | EXPIRED | REVOKED
  submittedAt DateTime?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String?
  createdBy   User?    @relation("IntakeLinkCreatedBy", fields: [createdById], references: [id])

  @@index([target])
  @@index([status])
  @@index([propertyId])
  @@index([bailId])
  @@index([clientId])
}

/**
 * ---------------------- Documents ------------------
 */

model Document {
  id       String       @id @default(cuid())
  kind     DocumentKind @default(ID_IDENTITY)
  label    String?
  fileKey  String // clé S3/GCS
  mimeType String?
  size     Int?

  personId String?
  person   Person? @relation(fields: [personId], references: [id], onDelete: Cascade)

  entrepriseId String?
  entreprise   Entreprise? @relation(fields: [entrepriseId], references: [id], onDelete: Cascade)

  clientId String?
  client   Client? @relation(fields: [clientId], references: [id], onDelete: Cascade)

  propertyId String?
  property   Property? @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  bailId String?
  bail   Bail?   @relation(fields: [bailId], references: [id], onDelete: Cascade)

  // Lien direct avec une demande de notaire (pour les documents fournis en réponse)
  notaireRequestId String?
  notaireRequest   NotaireRequest? @relation("NotaireRequestDocuments", fields: [notaireRequestId], references: [id], onDelete: SetNull)

  bailMessages BailMessage[] @relation("BailMessageDocument")

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  uploadedById String?
  uploadedBy   User?    @relation("DocumentUploadedBy", fields: [uploadedById], references: [id])

  @@index([kind])
  @@index([personId])
  @@index([entrepriseId])
  @@index([propertyId])
  @@index([bailId])
  @@index([uploadedById])
  @@index([fileKey])
  @@index([notaireRequestId])
}

/**
 * ---------------------- Comments (polymorphe) ------
 */

model CommentInterface {
  id       String        @id @default(cuid())
  target   CommentTarget
  targetId String // id de Party/Property/Lease/Document/IntakeLink
  body     String

  createdAt   DateTime @default(now())
  createdById String
  createdBy   User     @relation("CommentCreatedBy", fields: [createdById], references: [id])

  // Relation pour suivre quels utilisateurs ont lu ce commentaire
  readBy CommentRead[]

  @@index([target, targetId])
  @@index([createdById])
}

/**
 * ---------------------- Comment Read Status ------
 * Table de jointure pour suivre quels commentaires ont été lus par quels utilisateurs
 */

model CommentRead {
  id        String           @id @default(cuid())
  commentId String
  comment   CommentInterface @relation(fields: [commentId], references: [id], onDelete: Cascade)
  userId    String
  user      User             @relation("CommentReadByUser", fields: [userId], references: [id], onDelete: Cascade)
  readAt    DateTime         @default(now())

  @@unique([commentId, userId])
  @@index([commentId])
  @@index([userId])
  @@index([readAt])
}

/**
 * ---------------------- Notifications ------------------
 */

model Notification {
  id     String           @id @default(cuid())
  type   NotificationType
  isRead Boolean          @default(false)

  // Données polymorphes pour identifier l'entité concernée
  targetType String? // CLIENT, PROPERTY, BAIL, INTAKE, COMMENT
  targetId   String? // ID de l'entité concernée

  // Métadonnées supplémentaires (JSON pour flexibilité)
  metadata Json? // Ex: { oldStatus, newStatus, createdByForm, etc. }

  // Relations
  createdById String? // Utilisateur qui a déclenché l'événement (peut être null si créé par formulaire)
  createdBy   User?   @relation("NotificationCreatedBy", fields: [createdById], references: [id])

  recipientId String // Utilisateur qui reçoit la notification
  recipient   User   @relation("NotificationReceivedBy", fields: [recipientId], references: [id], onDelete: Cascade)

  createdAt DateTime  @default(now())
  readAt    DateTime?

  @@index([recipientId])
  @@index([isRead])
  @@index([type])
  @@index([targetType, targetId])
  @@index([createdAt])
}

/**
 * ---------------------- Better Auth Models ----------
 */

model Session {
  id        String   @id @default(cuid())
  expiresAt DateTime
  token     String   @unique
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([token])
}

model Account {
  id                    String    @id @default(cuid())
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@index([userId])
}

model Verification {
  id         String   @id @default(cuid())
  identifier String   @unique
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

/**
 * ---------------------- Notaire Assignments ------------------
 */

model DossierNotaireAssignment {
  id String @id @default(cuid())

  // Relations vers les entités du dossier
  clientId String
  client   Client @relation("DossierNotaireAssignments", fields: [clientId], references: [id], onDelete: Cascade)

  propertyId String?
  property   Property? @relation("DossierNotaireAssignments", fields: [propertyId], references: [id], onDelete: Cascade)

  bailId String?
  bail   Bail?   @relation("DossierNotaireAssignments", fields: [bailId], references: [id], onDelete: Cascade)

  // Notaire assigné
  notaireId String
  notaire   User   @relation("NotaireAssignments", fields: [notaireId], references: [id], onDelete: Cascade)

  // Métadonnées
  assignedAt   DateTime @default(now())
  assignedById String
  assignedBy   User     @relation("DossierAssignmentsCreated", fields: [assignedById], references: [id])

  notes String? // Notes optionnelles pour l'assignation

  // Relations pour les demandes
  requests NotaireRequest[] @relation("DossierRequests")

  @@unique([clientId, propertyId, bailId, notaireId])
  @@index([notaireId])
  @@index([clientId])
  @@index([bailId])
}

/**
 * ---------------------- Notaire Requests ------------------
 * Demandes du notaire pour des documents aux parties
 */

enum NotaireRequestStatus {
  PENDING // En attente de réponse
  COMPLETED // Complétée
  CANCELLED // Annulée
}

model NotaireRequest {
  id String @id @default(cuid())

  // Dossier associé
  dossierId String
  dossier   DossierNotaireAssignment @relation("DossierRequests", fields: [dossierId], references: [id], onDelete: Cascade)

  // Contenu de la demande
  title   String // Titre de la demande
  content String // Contenu détaillé (textarea)

  // Destinataires (peut être propriétaire, locataire, ou les deux)
  targetProprietaire Boolean  @default(false)
  targetLocataire    Boolean  @default(false)
  // IDs des parties spécifiques ciblées (si vide, cible tous les propriétaires/locataires selon les flags ci-dessus)
  targetPartyIds     String[] @default([])

  // Statut
  status NotaireRequestStatus @default(PENDING)

  // Métadonnées
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String
  createdBy   User     @relation("NotaireRequestCreatedBy", fields: [createdById], references: [id])

  // Messages de chat liés à cette demande
  bailMessages BailMessage[] @relation("BailMessageRequest")

  // Documents fournis en réponse à cette demande
  documents Document[] @relation("NotaireRequestDocuments")

  @@index([dossierId])
  @@index([status])
  @@index([createdById])
}

/**
 * ---------------------- OTP Codes ------------------
 */

model OTPCode {
  id        String   @id @default(cuid())
  email     String
  code      String // Code OTP (6 chiffres)
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([email, used])
  @@index([expiresAt])
}
